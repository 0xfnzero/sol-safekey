//! Interactive Menu Module
//!
//! Provides a simple interactive interface - no need to memorize commands
//! Êèê‰æõÁÆÄÂçïÁöÑ‰∫§‰∫íÂºèÁïåÈù¢ - Êó†ÈúÄËÆ∞‰ΩèÂëΩ‰ª§

use std::io::{self, Write};
use colored::*;
use solana_sdk::signature::Keypair;
use solana_sdk::signer::Signer;

use crate::KeyManager;

/// Language selection
#[derive(Clone, Copy, PartialEq)]
pub enum Language {
    English,
    Chinese,
}

/// Text strings for bilingual UI
struct Texts {
    // Main menu
    title: &'static str,
    core_functions: &'static str,
    create_plain: &'static str,
    create_encrypted: &'static str,
    decrypt: &'static str,
    exit: &'static str,
    select_option: &'static str,
    goodbye: &'static str,
    invalid_option: &'static str,
    continue_use: &'static str,

    // Plain key creation
    create_plain_title: &'static str,
    keypair_generated: &'static str,
    public_key: &'static str,
    private_key: &'static str,
    output_method: &'static str,
    display_only: &'static str,
    save_to_file: &'static str,
    select: &'static str,
    file_path: &'static str,
    file_saved: &'static str,
    security_warning: &'static str,
    plaintext_warning: &'static str,
    save_securely: &'static str,
    dont_share: &'static str,
    recommend_encrypted: &'static str,

    // Encrypted key creation
    create_encrypted_title: &'static str,
    choose_method: &'static str,
    generate_new: &'static str,
    import_existing: &'static str,
    generating: &'static str,
    enter_private_key: &'static str,
    private_key_empty: &'static str,
    keypair_ready: &'static str,
    keystore_recommended: &'static str,
    show_encrypted_string: &'static str,
    keystore_created: &'static str,
    private_key_encrypted: &'static str,
    important_note: &'static str,
    keep_safe: &'static str,
    lost_password_warning: &'static str,
    backup_recommended: &'static str,
    encrypted_private_key: &'static str,
    keep_safe_both: &'static str,

    // Key decryption
    decrypt_title: &'static str,
    input_method: &'static str,
    from_keystore: &'static str,
    from_encrypted_string: &'static str,
    encrypted_key: &'static str,
    enter_password: &'static str,
    decrypt_success: &'static str,
    file_not_exist: &'static str,
    dont_share_warning: &'static str,
    delete_plaintext: &'static str,
    use_encryption: &'static str,

    // Password
    set_password: &'static str,
    new_password: &'static str,
    confirm_password: &'static str,
    password_empty: &'static str,
    password_min_length: &'static str,
    password_mismatch: &'static str,
    password_set: &'static str,

    // Errors
    invalid_choice: &'static str,
    write_failed: &'static str,
}

impl Texts {
    fn chinese() -> Self {
        Self {
            title: "  Sol-SafeKey - Solana ÂØÜÈí•ÁÆ°ÁêÜÂ∑•ÂÖ∑",
            core_functions: "Ê†∏ÂøÉÂäüËÉΩ (Âè™ÈúÄ3‰∏™Êìç‰Ωú):",
            create_plain: "  {}  ÂàõÂª∫ÊòéÊñáÁßÅÈí•",
            create_encrypted: "  {}  ÂàõÂª∫Âä†ÂØÜÁßÅÈí•",
            decrypt: "  {}  Ëß£ÂØÜÁßÅÈí•",
            exit: "  {}  ÈÄÄÂá∫",
            select_option: "ËØ∑ËæìÂÖ•ÈÄâÈ°π [0-12]: ",
            goodbye: "üëã ÂÜçËßÅÔºÅ",
            invalid_option: "‚ùå Êó†ÊïàÈÄâÈ°πÔºåËØ∑ÈáçÊñ∞ÈÄâÊã©",
            continue_use: "ÊòØÂê¶ÁªßÁª≠‰ΩøÁî®? [Y/n]: ",

            create_plain_title: "  ÂàõÂª∫ÊòéÊñáÁßÅÈí•",
            keypair_generated: "‚úÖ ÂØÜÈí•ÂØπÁîüÊàêÊàêÂäüÔºÅ",
            public_key: "ÂÖ¨Èí•Âú∞ÂùÄ:",
            private_key: "ÁßÅÈí•:",
            output_method: "ËæìÂá∫ÊñπÂºè:",
            display_only: "  1. ‰ªÖÊòæÁ§∫ (ÂΩìÂâçÂ∑≤ÊòæÁ§∫)",
            save_to_file: "  2. ‰øùÂ≠òÂà∞Êñá‰ª∂",
            select: "ËØ∑ÈÄâÊã© [1/2]: ",
            file_path: "Êñá‰ª∂Ë∑ØÂæÑ (ÈªòËÆ§: keypair.json): ",
            file_saved: "‚úÖ Â∑≤‰øùÂ≠òÂà∞Êñá‰ª∂",
            security_warning: "‚ö†Ô∏è  ÂÆâÂÖ®Ë≠¶Âëä:",
            plaintext_warning: "  ‚Ä¢ ÊòéÊñáÁßÅÈí•ÈùûÂ∏∏‰∏çÂÆâÂÖ®",
            save_securely: "  ‚Ä¢ ËØ∑Á´ãÂç≥‰øùÂ≠òÂà∞ÂÆâÂÖ®‰ΩçÁΩÆ",
            dont_share: "  ‚Ä¢ ‰∏çË¶ÅÂàÜ‰∫´Áªô‰ªª‰Ωï‰∫∫",
            recommend_encrypted: "  ‚Ä¢ Âª∫ËÆÆ‰ΩøÁî® 'ÂàõÂª∫Âä†ÂØÜÁßÅÈí•' ÂäüËÉΩ",

            create_encrypted_title: "  ÂàõÂª∫Âä†ÂØÜÁßÅÈí•",
            choose_method: "ÈÄâÊã©ÊñπÂºè:",
            generate_new: "  1. ÁîüÊàêÊñ∞ÁöÑÂØÜÈí•ÂØπÂπ∂Âä†ÂØÜ",
            import_existing: "  2. ÂØºÂÖ•Áé∞ÊúâÁßÅÈí•Âπ∂Âä†ÂØÜ",
            generating: "üé≤ ÁîüÊàêÊñ∞ÁöÑÂØÜÈí•ÂØπ...",
            enter_private_key: "ËØ∑ËæìÂÖ•ÁßÅÈí• (base58 Ê†ºÂºè): ",
            private_key_empty: "ÁßÅÈí•‰∏çËÉΩ‰∏∫Á©∫",
            keypair_ready: "‚úÖ ÂØÜÈí•ÂØπÂáÜÂ§áÂÆåÊàê",
            keystore_recommended: "  1. ‰øùÂ≠ò‰∏∫ Keystore Êñá‰ª∂ (Êé®Ëçê)",
            show_encrypted_string: "  2. ÊòæÁ§∫Âä†ÂØÜÂ≠óÁ¨¶‰∏≤",
            keystore_created: "  ‚úÖ Keystore ÂàõÂª∫ÊàêÂäüÔºÅ",
            private_key_encrypted: "üîí ÁßÅÈí•Â∑≤Âä†ÂØÜ‰øùÂ≠ò",
            important_note: "‚ö†Ô∏è  ÈáçË¶ÅÊèêÁ§∫:",
            keep_safe: "  ‚Ä¢ ËØ∑Â¶•ÂñÑ‰øùÁÆ° Keystore Êñá‰ª∂ÂíåÂØÜÁ†Å",
            lost_password_warning: "  ‚Ä¢ ‰∏¢Â§±ÂØÜÁ†ÅÂ∞ÜÊó†Ê≥ïÊÅ¢Â§çÈí±ÂåÖ",
            backup_recommended: "  ‚Ä¢ Âª∫ËÆÆÂ§á‰ªΩÂà∞ÂÆâÂÖ®‰ΩçÁΩÆ",
            encrypted_private_key: "Âä†ÂØÜÂêéÁöÑÁßÅÈí•:",
            keep_safe_both: "‚ö†Ô∏è  ÊèêÁ§∫: ËØ∑Â¶•ÂñÑ‰øùÁÆ°Âä†ÂØÜÁßÅÈí•ÂíåÂØÜÁ†Å",

            decrypt_title: "  Ëß£ÂØÜÁßÅÈí•",
            input_method: "ËæìÂÖ•ÊñπÂºè:",
            from_keystore: "  1. ‰ªé Keystore Êñá‰ª∂ËØªÂèñ",
            from_encrypted_string: "  2. ËæìÂÖ•Âä†ÂØÜÂ≠óÁ¨¶‰∏≤",
            encrypted_key: "Âä†ÂØÜÁöÑÁßÅÈí•: ",
            enter_password: "ËØ∑ËæìÂÖ•ÂØÜÁ†Å: ",
            decrypt_success: "  ‚úÖ Ëß£ÂØÜÊàêÂäüÔºÅ",
            file_not_exist: "Êñá‰ª∂‰∏çÂ≠òÂú®: {}",
            dont_share_warning: "  ‚Ä¢ ËØ∑ÂãøÂàÜ‰∫´ÁßÅÈí•Áªô‰ªª‰Ωï‰∫∫",
            delete_plaintext: "  ‚Ä¢ ‰ΩøÁî®ÂÆåÊØïÂêéËØ∑Á´ãÂç≥Âà†Èô§ÊòéÊñáÁßÅÈí•Êñá‰ª∂",
            use_encryption: "  ‚Ä¢ Âª∫ËÆÆ‰ΩøÁî®Âä†ÂØÜÊñπÂºè‰øùÂ≠ò",

            set_password: "ËÆæÁΩÆÂä†ÂØÜÂØÜÁ†Å (Ëá≥Â∞ë 10 ‰∏™Â≠óÁ¨¶):",
            new_password: "Êñ∞ÂØÜÁ†Å: ",
            confirm_password: "Á°ÆËÆ§ÂØÜÁ†Å: ",
            password_empty: "ÂØÜÁ†Å‰∏çËÉΩ‰∏∫Á©∫",
            password_min_length: "ÂØÜÁ†ÅÈïøÂ∫¶Ëá≥Â∞ë 10 ‰∏™Â≠óÁ¨¶",
            password_mismatch: "‰∏§Ê¨°ÂØÜÁ†Å‰∏ç‰∏ÄËá¥",
            password_set: "‚úÖ ÂØÜÁ†ÅËÆæÁΩÆÊàêÂäü",

            invalid_choice: "Êó†ÊïàÈÄâÈ°π",
            write_failed: "ÂÜôÂÖ•Êñá‰ª∂Â§±Ë¥•: {}",
        }
    }

    fn english() -> Self {
        Self {
            title: "  Sol-SafeKey - Solana Key Management Tool",
            core_functions: "Core Functions (3 operations):",
            create_plain: "  {}  Create Plain Private Key",
            create_encrypted: "  {}  Create Encrypted Private Key",
            decrypt: "  {}  Decrypt Private Key",
            exit: "  {}  Exit",
            select_option: "Select option [0-12]: ",
            goodbye: "üëã Goodbye!",
            invalid_option: "‚ùå Invalid option, please try again",
            continue_use: "Continue? [Y/n]: ",

            create_plain_title: "  Create Plain Private Key",
            keypair_generated: "‚úÖ Keypair generated successfully!",
            public_key: "Public Key:",
            private_key: "Private Key:",
            output_method: "Output Method:",
            display_only: "  1. Display Only (already shown)",
            save_to_file: "  2. Save to File",
            select: "Select [1/2]: ",
            file_path: "File path (default: keypair.json): ",
            file_saved: "‚úÖ Saved to file",
            security_warning: "‚ö†Ô∏è  Security Warning:",
            plaintext_warning: "  ‚Ä¢ Plaintext private key is very insecure",
            save_securely: "  ‚Ä¢ Save to a secure location immediately",
            dont_share: "  ‚Ä¢ Never share with anyone",
            recommend_encrypted: "  ‚Ä¢ Consider using 'Create Encrypted Private Key'",

            create_encrypted_title: "  Create Encrypted Private Key",
            choose_method: "Choose Method:",
            generate_new: "  1. Generate new keypair and encrypt",
            import_existing: "  2. Import existing private key and encrypt",
            generating: "üé≤ Generating new keypair...",
            enter_private_key: "Enter private key (base58 format): ",
            private_key_empty: "Private key cannot be empty",
            keypair_ready: "‚úÖ Keypair ready",
            keystore_recommended: "  1. Save as Keystore file (Recommended)",
            show_encrypted_string: "  2. Show encrypted string",
            keystore_created: "  ‚úÖ Keystore created successfully!",
            private_key_encrypted: "üîí Private key encrypted and saved",
            important_note: "‚ö†Ô∏è  Important:",
            keep_safe: "  ‚Ä¢ Keep Keystore file and password safe",
            lost_password_warning: "  ‚Ä¢ Lost password = lost wallet",
            backup_recommended: "  ‚Ä¢ Backup to a secure location",
            encrypted_private_key: "Encrypted Private Key:",
            keep_safe_both: "‚ö†Ô∏è  Note: Keep encrypted key and password safe",

            decrypt_title: "  Decrypt Private Key",
            input_method: "Input Method:",
            from_keystore: "  1. From Keystore file",
            from_encrypted_string: "  2. Enter encrypted string",
            encrypted_key: "Encrypted key: ",
            enter_password: "Enter password: ",
            decrypt_success: "  ‚úÖ Decryption successful!",
            file_not_exist: "File not found: {}",
            dont_share_warning: "  ‚Ä¢ Never share private key with anyone",
            delete_plaintext: "  ‚Ä¢ Delete plaintext key file after use",
            use_encryption: "  ‚Ä¢ Consider using encryption for storage",

            set_password: "Set encryption password (minimum 10 characters):",
            new_password: "New password: ",
            confirm_password: "Confirm password: ",
            password_empty: "Password cannot be empty",
            password_min_length: "Password must be at least 10 characters",
            password_mismatch: "Passwords do not match",
            password_set: "‚úÖ Password set successfully",

            invalid_choice: "Invalid choice",
            write_failed: "Write failed: {}",
        }
    }
}

/// ÈÄâÊã©ËØ≠Ë®Ä
fn select_language() -> Result<Language, String> {
    println!("\n{}", "=".repeat(50).cyan());
    println!("{}", "  Language / ËØ≠Ë®ÄÈÄâÊã©".cyan().bold());
    println!("{}", "=".repeat(50).cyan());
    println!();
    println!("  {}  English", "1.".green().bold());
    println!("  {}  ‰∏≠Êñá", "2.".green().bold());
    println!();
    print!("Select / ÈÄâÊã© [1/2]: ");
    io::stdout().flush().map_err(|e| e.to_string())?;

    let mut choice = String::new();
    io::stdin().read_line(&mut choice).map_err(|e| e.to_string())?;
    let choice = choice.trim();

    match choice {
        "1" => Ok(Language::English),
        "2" => Ok(Language::Chinese),
        _ => {
            println!("\n{}", "‚ùå Invalid option / Êó†ÊïàÈÄâÈ°π".red());
            select_language()
        }
    }
}

/// ÊòæÁ§∫‰∏ªËèúÂçïÂπ∂Â§ÑÁêÜÁî®Êà∑ÈÄâÊã©
pub fn show_main_menu() -> Result<(), String> {
    // È¶ñÂÖàÈÄâÊã©ËØ≠Ë®Ä
    let lang = select_language()?;
    let texts = match lang {
        Language::Chinese => Texts::chinese(),
        Language::English => Texts::english(),
    };

    loop {
        println!("\n{}", "=".repeat(50).cyan());
        println!("{}", texts.title.cyan().bold());
        println!("{}", "=".repeat(50).cyan());
        println!();
        println!("{}", texts.core_functions);
        println!();
        println!("  {}  {}", "1.".green().bold(), &texts.create_plain[6..]);
        println!("  {}  {}", "2.".green().bold(), &texts.create_encrypted[6..]);
        println!("  {}  {}", "3.".green().bold(), &texts.decrypt[6..]);

        // Advanced security features
        #[cfg(feature = "2fa")]
        {
            println!();
            if lang == Language::Chinese {
                println!("{}", "  È´òÁ∫ßÂÆâÂÖ®ÂäüËÉΩ:".bright_magenta().bold());
            } else {
                println!("{}", "  Advanced Security:".bright_magenta().bold());
            }
            println!("  {}  {}", "4.".bright_magenta().bold(), if lang == Language::Chinese { "ËÆæÁΩÆ 2FA ËÆ§ËØÅ" } else { "Setup 2FA Authentication" });
            println!("  {}  {}", "5.".bright_magenta().bold(), if lang == Language::Chinese { "ÁîüÊàê‰∏âÂõ†Â≠êÈí±ÂåÖ" } else { "Generate Triple-Factor Wallet" });
            println!("  {}  {}", "6.".bright_magenta().bold(), if lang == Language::Chinese { "Ëß£ÈîÅ‰∏âÂõ†Â≠êÈí±ÂåÖ" } else { "Unlock Triple-Factor Wallet" });
        }

        // Solana operations (if feature is enabled)
        #[cfg(feature = "solana-ops")]
        {
            println!();
            if lang == Language::Chinese {
                println!("{}", "  Solana Èìæ‰∏äÊìç‰Ωú:".bright_blue().bold());
            } else {
                println!("{}", "  Solana Operations:".bright_blue().bold());
            }
            #[cfg(feature = "2fa")]
            {
                println!("  {}  {}", "7.".bright_cyan().bold(), if lang == Language::Chinese { "Êü•ËØ¢ SOL ‰ΩôÈ¢ù" } else { "Check SOL Balance" });
                println!("  {}  {}", "8.".bright_cyan().bold(), if lang == Language::Chinese { "ËΩ¨Ë¥¶ SOL" } else { "Transfer SOL" });
                println!("  {}  {}", "9.".bright_cyan().bold(), if lang == Language::Chinese { "ÂåÖË£Ö SOL ‚Üí WSOL" } else { "Wrap SOL ‚Üí WSOL" });
                println!("  {}  {}", "10.".bright_cyan().bold(), if lang == Language::Chinese { "Ëß£ÂåÖ WSOL ‚Üí SOL" } else { "Unwrap WSOL ‚Üí SOL" });
                println!("  {}  {}", "11.".bright_cyan().bold(), if lang == Language::Chinese { "ËΩ¨Ë¥¶ SPL ‰ª£Â∏Å" } else { "Transfer SPL Token" });
                println!("  {}  {}", "12.".bright_cyan().bold(), if lang == Language::Chinese { "ÂàõÂª∫ Nonce Ë¥¶Êà∑" } else { "Create Nonce Account" });
            }
            #[cfg(not(feature = "2fa"))]
            {
                println!("  {}  {}", "4.".bright_cyan().bold(), if lang == Language::Chinese { "Êü•ËØ¢ SOL ‰ΩôÈ¢ù" } else { "Check SOL Balance" });
                println!("  {}  {}", "5.".bright_cyan().bold(), if lang == Language::Chinese { "ËΩ¨Ë¥¶ SOL" } else { "Transfer SOL" });
                println!("  {}  {}", "6.".bright_cyan().bold(), if lang == Language::Chinese { "ÂåÖË£Ö SOL ‚Üí WSOL" } else { "Wrap SOL ‚Üí WSOL" });
                println!("  {}  {}", "7.".bright_cyan().bold(), if lang == Language::Chinese { "Ëß£ÂåÖ WSOL ‚Üí SOL" } else { "Unwrap WSOL ‚Üí SOL" });
                println!("  {}  {}", "8.".bright_cyan().bold(), if lang == Language::Chinese { "ËΩ¨Ë¥¶ SPL ‰ª£Â∏Å" } else { "Transfer SPL Token" });
                println!("  {}  {}", "9.".bright_cyan().bold(), if lang == Language::Chinese { "ÂàõÂª∫ Nonce Ë¥¶Êà∑" } else { "Create Nonce Account" });
            }
        }

        println!();
        println!("  {}  {}", "0.".red().bold(), &texts.exit[6..]);
        println!();
        print!("{}", texts.select_option);
        io::stdout().flush().map_err(|e| e.to_string())?;

        let mut choice = String::new();
        io::stdin().read_line(&mut choice).map_err(|e| e.to_string())?;
        let choice = choice.trim();

        match choice {
            "1" => create_plain_key_interactive(&texts)?,
            "2" => create_encrypted_key_interactive(&texts)?,
            "3" => decrypt_key_interactive(&texts)?,

            // Advanced security features (2FA)
            #[cfg(feature = "2fa")]
            "4" => {
                if let Err(e) = setup_2fa_interactive(lang) {
                    eprintln!("‚ùå {}", e);
                }
            }
            #[cfg(feature = "2fa")]
            "5" => {
                if let Err(e) = generate_triple_factor_wallet_interactive(lang) {
                    eprintln!("‚ùå {}", e);
                }
            }
            #[cfg(feature = "2fa")]
            "6" => {
                if let Err(e) = unlock_triple_factor_wallet_interactive(lang) {
                    eprintln!("‚ùå {}", e);
                }
            }

            // Solana operations
            #[cfg(all(feature = "solana-ops", feature = "2fa"))]
            "7" | "8" | "9" | "10" | "11" | "12" => {
                if let Err(e) = handle_solana_operation(choice, lang) {
                    eprintln!("‚ùå {}", e);
                }
            }
            #[cfg(all(feature = "solana-ops", not(feature = "2fa")))]
            "4" | "5" | "6" | "7" | "8" | "9" => {
                if let Err(e) = handle_solana_operation(choice, lang) {
                    eprintln!("‚ùå {}", e);
                }
            }

            "0" => {
                println!("\n{}", texts.goodbye.cyan());
                break;
            }
            _ => {
                println!("\n{}", texts.invalid_option.red());
                continue;
            }
        }

        // ËØ¢ÈóÆÊòØÂê¶ÁªßÁª≠
        println!();
        print!("{}", texts.continue_use);
        io::stdout().flush().map_err(|e| e.to_string())?;

        let mut continue_choice = String::new();
        io::stdin().read_line(&mut continue_choice).map_err(|e| e.to_string())?;
        let continue_choice = continue_choice.trim().to_lowercase();

        if continue_choice == "n" || continue_choice == "no" {
            println!("\n{}", texts.goodbye.cyan());
            break;
        }
    }

    Ok(())
}

/// ÂäüËÉΩ1: ÂàõÂª∫ÊòéÊñáÁßÅÈí•
fn create_plain_key_interactive(texts: &Texts) -> Result<(), String> {
    println!("\n{}", "=".repeat(50).yellow());
    println!("{}", texts.create_plain_title.yellow().bold());
    println!("{}", "=".repeat(50).yellow());
    println!();

    // ÁîüÊàêÂØÜÈí•ÂØπ
    let keypair = KeyManager::generate_keypair();
    let pubkey = keypair.pubkey();
    let private_key = keypair.to_base58_string();

    println!("{}", texts.keypair_generated.green().bold());
    println!();
    println!("{} {}", texts.public_key.cyan(), pubkey.to_string().white().bold());
    println!("{} {}", texts.private_key.red().bold(), private_key);
    println!();

    // ËØ¢ÈóÆËæìÂá∫ÊñπÂºè
    println!("{}",texts.output_method);
    println!("{}", texts.display_only);
    println!("{}", texts.save_to_file);
    println!();
    print!("{}", texts.select);
    io::stdout().flush().map_err(|e| e.to_string())?;

    let mut output_choice = String::new();
    io::stdin().read_line(&mut output_choice).map_err(|e| e.to_string())?;
    let output_choice = output_choice.trim();

    if output_choice == "2" {
        print!("{}", texts.file_path);
        io::stdout().flush().map_err(|e| e.to_string())?;

        let mut file_path = String::new();
        io::stdin().read_line(&mut file_path).map_err(|e| e.to_string())?;
        let file_path = file_path.trim();
        let file_path = if file_path.is_empty() {
            "keypair.json"
        } else {
            file_path
        };

        // ‰øùÂ≠ò‰∏∫ Solana keypair JSON Ê†ºÂºè (Êï∞ÁªÑÊ†ºÂºè)
        let bytes = keypair.to_bytes();
        let json = serde_json::to_string(&bytes.to_vec())
            .map_err(|e| format!("{}", texts.write_failed.replace("{}", &e.to_string())))?;

        std::fs::write(file_path, json)
            .map_err(|e| format!("{}", texts.write_failed.replace("{}", &e.to_string())))?;

        println!();
        println!("{}", texts.file_saved.green());
        println!("{} {}", texts.file_path.trim_end_matches(':'), file_path);
    }

    println!();
    println!("{}", texts.security_warning.yellow().bold());
    println!("{}", texts.plaintext_warning);
    println!("{}", texts.save_securely);
    println!("{}", texts.dont_share);
    println!("{}", texts.recommend_encrypted);

    Ok(())
}

/// ÂäüËÉΩ2: ÂàõÂª∫Âä†ÂØÜÁßÅÈí•
fn create_encrypted_key_interactive(texts: &Texts) -> Result<(), String> {
    println!("\n{}", "=".repeat(50).yellow());
    println!("{}", texts.create_encrypted_title.yellow().bold());
    println!("{}", "=".repeat(50).yellow());
    println!();

    // ËØ¢ÈóÆÊòØÁîüÊàêÊñ∞ÁöÑËøòÊòØÂØºÂÖ•Áé∞ÊúâÁßÅÈí•
    println!("{}", texts.choose_method);
    println!("{}", texts.generate_new);
    println!("{}", texts.import_existing);
    println!();
    print!("{}", texts.select);
    io::stdout().flush().map_err(|e| e.to_string())?;

    let mut source_choice = String::new();
    io::stdin().read_line(&mut source_choice).map_err(|e| e.to_string())?;
    let source_choice = source_choice.trim();

    let keypair = match source_choice {
        "1" => {
            // ÁîüÊàêÊñ∞ÂØÜÈí•ÂØπ
            println!();
            println!("{}", texts.generating.cyan());
            KeyManager::generate_keypair()
        }
        "2" => {
            // ÂØºÂÖ•Áé∞ÊúâÁßÅÈí•
            println!();
            print!("{}", texts.enter_private_key);
            io::stdout().flush().map_err(|e| e.to_string())?;

            let mut private_key = String::new();
            io::stdin().read_line(&mut private_key).map_err(|e| e.to_string())?;
            let private_key = private_key.trim();

            if private_key.is_empty() {
                return Err(texts.private_key_empty.to_string());
            }

            Keypair::from_base58_string(private_key)
        }
        _ => {
            return Err(texts.invalid_choice.to_string());
        }
    };

    let pubkey = keypair.pubkey();

    println!();
    println!("{}", texts.keypair_ready.green());
    println!("{} {}", texts.public_key.cyan(), pubkey);
    println!();

    // Ëé∑ÂèñÂØÜÁ†Å
    let password = read_password_confirmed(texts)?;

    // ËØ¢ÈóÆËæìÂá∫ÊñπÂºè
    println!();
    println!("{}", texts.output_method);
    println!("{}", texts.keystore_recommended);
    println!("{}", texts.show_encrypted_string);
    println!();
    print!("{}", texts.select);
    io::stdout().flush().map_err(|e| e.to_string())?;

    let mut output_choice = String::new();
    io::stdin().read_line(&mut output_choice).map_err(|e| e.to_string())?;
    let output_choice = output_choice.trim();

    match output_choice {
        "1" => {
            // ‰øùÂ≠ò‰∏∫Êñá‰ª∂
            print!("{}", texts.file_path.replace("keypair", "wallet"));
            io::stdout().flush().map_err(|e| e.to_string())?;

            let mut file_path = String::new();
            io::stdin().read_line(&mut file_path).map_err(|e| e.to_string())?;
            let file_path = file_path.trim();
            let file_path = if file_path.is_empty() {
                "wallet.json"
            } else {
                file_path
            };

            let keystore_json = KeyManager::keypair_to_encrypted_json(&keypair, &password)?;
            std::fs::write(file_path, keystore_json)
                .map_err(|e| format!("{}", texts.write_failed.replace("{}", &e.to_string())))?;

            println!();
            println!("{}", "=".repeat(50).green());
            println!("{}", texts.keystore_created.green().bold());
            println!("{}", "=".repeat(50).green());
            println!();
            println!("{} {}", texts.file_path.trim_end_matches(':'), file_path);
            println!("{} {}", texts.public_key.cyan(), pubkey);
            println!("{}", texts.private_key_encrypted.green());
            println!();
            println!("{}", texts.important_note.yellow().bold());
            println!("{}", texts.keep_safe);
            println!("{}", texts.lost_password_warning);
            println!("{}", texts.backup_recommended);
        }
        "2" => {
            // ÊòæÁ§∫Âä†ÂØÜÂ≠óÁ¨¶‰∏≤
            let private_key = keypair.to_base58_string();
            let encrypted = KeyManager::encrypt_with_password(&private_key, &password)?;

            println!();
            println!("{}", texts.keypair_ready.green().bold());
            println!();
            println!("{} {}", texts.public_key.cyan(), pubkey);
            println!("{}", texts.encrypted_private_key.cyan());
            println!("{}", encrypted);
            println!();
            println!("{}", texts.keep_safe_both.yellow());
        }
        _ => {
            return Err(texts.invalid_choice.to_string());
        }
    }

    Ok(())
}

/// ÂäüËÉΩ3: Ëß£ÂØÜÁßÅÈí•
fn decrypt_key_interactive(texts: &Texts) -> Result<(), String> {
    println!("\n{}", "=".repeat(50).yellow());
    println!("{}", texts.decrypt_title.yellow().bold());
    println!("{}", "=".repeat(50).yellow());
    println!();

    // ÈÄâÊã©ËæìÂÖ•ÊñπÂºè
    println!("{}", texts.input_method);
    println!("{}", texts.from_keystore);
    println!("{}", texts.from_encrypted_string);
    println!();
    print!("{}", texts.select);
    io::stdout().flush().map_err(|e| e.to_string())?;

    let mut input_choice = String::new();
    io::stdin().read_line(&mut input_choice).map_err(|e| e.to_string())?;
    let input_choice = input_choice.trim();

    let (private_key, pubkey) = match input_choice {
        "1" => {
            // ‰ªéÊñá‰ª∂ËØªÂèñ
            print!("{}", texts.file_path.trim_end_matches("(ÈªòËÆ§: keypair.json): ").trim_end_matches("(default: keypair.json): "));
            io::stdout().flush().map_err(|e| e.to_string())?;

            let mut file_path = String::new();
            io::stdin().read_line(&mut file_path).map_err(|e| e.to_string())?;
            let file_path = file_path.trim();

            if !std::path::Path::new(file_path).exists() {
                return Err(format!("{}", texts.file_not_exist.replace("{}", file_path)));
            }

            println!();
            let password = prompt_password(texts.enter_password, texts)?;

            let keystore_json = std::fs::read_to_string(file_path)
                .map_err(|e| format!("{}", texts.write_failed.replace("{}", &e.to_string())))?;

            let keypair = KeyManager::keypair_from_encrypted_json(&keystore_json, &password)?;
            let pubkey = keypair.pubkey();
            let private_key = keypair.to_base58_string();

            (private_key, pubkey)
        }
        "2" => {
            // ËæìÂÖ•Âä†ÂØÜÂ≠óÁ¨¶‰∏≤
            print!("{}", texts.encrypted_key);
            io::stdout().flush().map_err(|e| e.to_string())?;

            let mut encrypted = String::new();
            io::stdin().read_line(&mut encrypted).map_err(|e| e.to_string())?;
            let encrypted = encrypted.trim();

            println!();
            let password = prompt_password(texts.enter_password, texts)?;

            let private_key = KeyManager::decrypt_with_password(encrypted, &password)?;
            let keypair = Keypair::from_base58_string(&private_key);
            let pubkey = keypair.pubkey();

            (private_key, pubkey)
        }
        _ => {
            return Err(texts.invalid_choice.to_string());
        }
    };

    println!();
    println!("{}", "=".repeat(50).green());
    println!("{}", texts.decrypt_success.green().bold());
    println!("{}", "=".repeat(50).green());
    println!();
    println!("{} {}", texts.public_key.cyan(), pubkey);
    println!("{} {}", texts.private_key.red().bold(), private_key);
    println!();

    // ËØ¢ÈóÆËæìÂá∫ÊñπÂºè
    println!("{}", texts.output_method);
    println!("{}", texts.display_only);
    println!("{}", texts.save_to_file);
    println!();
    print!("{}", texts.select);
    io::stdout().flush().map_err(|e| e.to_string())?;

    let mut output_choice = String::new();
    io::stdin().read_line(&mut output_choice).map_err(|e| e.to_string())?;
    let output_choice = output_choice.trim();

    if output_choice == "2" {
        let default_filename = if texts.file_path.contains("ÈªòËÆ§") {
            "decrypted_key.txt"
        } else {
            "decrypted_key.txt"
        };

        print!("{}", texts.file_path.replace("keypair.json", default_filename));
        io::stdout().flush().map_err(|e| e.to_string())?;

        let mut file_path = String::new();
        io::stdin().read_line(&mut file_path).map_err(|e| e.to_string())?;
        let file_path = file_path.trim();
        let file_path = if file_path.is_empty() {
            default_filename
        } else {
            file_path
        };

        let content = format!("{} {}\n{} {}\n", texts.public_key, pubkey, texts.private_key.trim_end_matches(':'), private_key);
        std::fs::write(file_path, content)
            .map_err(|e| format!("{}", texts.write_failed.replace("{}", &e.to_string())))?;

        println!();
        println!("{}", texts.file_saved.green());
        println!("{} {}", texts.file_path.trim_end_matches(':'), file_path);
    }

    println!();
    println!("{}", texts.security_warning.yellow().bold());
    println!("{}", texts.dont_share_warning);
    println!("{}", texts.delete_plaintext);
    println!("{}", texts.use_encryption);

    Ok(())
}

/// ËØªÂèñÂØÜÁ†ÅÔºà‰∏¥Êó∂ÊòæÁ§∫ÊòéÊñáÁî®‰∫éË∞ÉËØïÔºâ
/// Prompt and read password securely
fn prompt_password(prompt: &str, texts: &Texts) -> Result<String, String> {
    print!("{}", prompt);
    io::stdout().flush().map_err(|e| e.to_string())?;

    // ‰∏¥Êó∂‰ΩøÁî®ÊòéÊñáËæìÂÖ•ËøõË°åË∞ÉËØï
    let mut password = String::new();
    io::stdin().read_line(&mut password)
        .map_err(|e| format!("{}", texts.write_failed.replace("{}", &e.to_string())))?;

    let password = password.trim().to_string();
    println!("DEBUG: ËØªÂèñÂà∞ÁöÑÂØÜÁ†Å: '{}' (ÈïøÂ∫¶: {})", password, password.len());

    Ok(password)

    // ÂéüÊù•ÁöÑÈöêËóèËæìÂÖ•‰ª£Á†ÅÔºàË∞ÉËØïÂÆåÊàêÂêéÊÅ¢Â§çÔºâ
    // let password = rpassword::read_password()
    //     .map_err(|e| format!("{}", texts.write_failed.replace("{}", &e.to_string())))?;
    // Ok(password.trim().to_string())
}

/// Handle Solana operation by prompting for keystore and calling the appropriate function
#[cfg(feature = "solana-ops")]
fn handle_solana_operation(choice: &str, language: Language) -> Result<(), String> {
    use rpassword;

    // Convert Language to operations::Language
    let ops_language = match language {
        Language::English => crate::operations::Language::English,
        Language::Chinese => crate::operations::Language::Chinese,
    };

    // Prompt for keystore file path
    println!();
    if language == Language::Chinese {
        print!("Keystore Êñá‰ª∂Ë∑ØÂæÑ [keystore.json]: ");
    } else {
        print!("Keystore file path [keystore.json]: ");
    }
    io::stdout().flush().map_err(|e| e.to_string())?;

    let mut keystore_path = String::new();
    io::stdin().read_line(&mut keystore_path).map_err(|e| e.to_string())?;
    let keystore_path = keystore_path.trim();
    let keystore_path = if keystore_path.is_empty() {
        "keystore.json"
    } else {
        keystore_path
    };

    // Read encrypted file
    let file_content = std::fs::read_to_string(keystore_path)
        .map_err(|e| format!("Failed to read keystore: {}", e))?;

    // Parse JSON to get encryption type
    let json: serde_json::Value = serde_json::from_str(&file_content)
        .map_err(|e| format!("Failed to parse keystore: {}", e))?;

    let encryption_type = json["encryption_type"].as_str().unwrap_or("password_only");

    // Decrypt keypair
    let keypair = match encryption_type {
        "password_only" => {
            // Simple password-based decryption
            let password = rpassword::prompt_password(
                if language == Language::Chinese { "ËæìÂÖ•ÂØÜÁ†Å: " } else { "Enter password: " }
            ).map_err(|e| format!("Failed to read password: {}", e))?;

            KeyManager::keypair_from_encrypted_json(&file_content, &password)
                .map_err(|e| format!("Failed to decrypt keystore: {}", e))?
        }
        "triple_factor_v1" => {
            return Err("Triple-factor wallets not yet supported in interactive mode. Please use the CLI.".to_string());
        }
        _ => {
            return Err(format!("Unknown encryption type: {}", encryption_type));
        }
    };

    if language == Language::Chinese {
        println!("‚úÖ Èí±ÂåÖËß£ÈîÅÊàêÂäüÔºÅ");
        println!("üìç Èí±ÂåÖÂú∞ÂùÄ: {}", keypair.pubkey());
    } else {
        println!("‚úÖ Wallet unlocked successfully!");
        println!("üìç Wallet address: {}", keypair.pubkey());
    }

    // Call the appropriate operation
    #[cfg(feature = "2fa")]
    let result = match choice {
        "7" => crate::operations::check_balance(&keypair, ops_language),
        "8" => crate::operations::transfer_sol(&keypair, ops_language),
        "9" => crate::operations::wrap_sol(&keypair, ops_language),
        "10" => crate::operations::unwrap_sol(&keypair, ops_language),
        "11" => crate::operations::transfer_token(&keypair, ops_language),
        "12" => crate::operations::create_nonce_account(&keypair, ops_language),
        _ => Err("Invalid operation".to_string()),
    };

    #[cfg(not(feature = "2fa"))]
    let result = match choice {
        "4" => crate::operations::check_balance(&keypair, ops_language),
        "5" => crate::operations::transfer_sol(&keypair, ops_language),
        "6" => crate::operations::wrap_sol(&keypair, ops_language),
        "7" => crate::operations::unwrap_sol(&keypair, ops_language),
        "8" => crate::operations::transfer_token(&keypair, ops_language),
        "9" => crate::operations::create_nonce_account(&keypair, ops_language),
        _ => Err("Invalid operation".to_string()),
    };

    result
}

/// Setup 2FA authentication interactively
#[cfg(feature = "2fa")]
fn setup_2fa_interactive(language: Language) -> Result<(), String> {
    use crate::{derive_totp_secret_from_hardware_and_password, hardware_fingerprint::HardwareFingerprint, security_question::SecurityQuestion, totp::*};
    use rpassword;

    let account = "wallet";
    let issuer = "Sol-SafeKey";

    println!("\n{}", "=".repeat(50).bright_magenta());
    if language == Language::Chinese {
        println!("{}", "  üîê ‰∏âÂõ†Â≠ê 2FA ÂÆâÂÖ®ËÆæÁΩÆ".bright_magenta().bold());
    } else {
        println!("{}", "  üîê Triple-Factor 2FA Security Setup".bright_magenta().bold());
    }
    println!("{}", "=".repeat(50).bright_magenta());
    println!();

    if language == Language::Chinese {
        println!("{}", "‚ö†Ô∏è  ÂÆâÂÖ®Êû∂ÊûÑËØ¥Êòé:".yellow().bold());
        println!("  ‚Ä¢ Âõ†Â≠ê1: Á°¨‰ª∂ÊåáÁ∫πÔºàËá™Âä®Êî∂ÈõÜÔºåÁªëÂÆöËÆæÂ§áÔºâ");
        println!("  ‚Ä¢ Âõ†Â≠ê2: ‰∏ªÂØÜÁ†ÅÔºàÊÇ®ËÆæÁΩÆÁöÑÂº∫ÂØÜÁ†ÅÔºâ");
        println!("  ‚Ä¢ Âõ†Â≠ê3: ÂÆâÂÖ®ÈóÆÈ¢òÁ≠îÊ°àÔºàÈò≤Ê≠¢ÂØÜÁ†ÅÊ≥ÑÈú≤Ôºâ");
        println!("  ‚Ä¢ 2FAÂØÜÈí•: ‰ªéÁ°¨‰ª∂ÊåáÁ∫π+‰∏ªÂØÜÁ†ÅÊ¥æÁîüÔºàÁ°ÆÂÆöÊÄßÔºâ");
        println!("  ‚Ä¢ Ëß£ÈîÅÈúÄË¶Å: ‰∏ªÂØÜÁ†Å + ÂÆâÂÖ®ÈóÆÈ¢òÁ≠îÊ°à + 2FAÂä®ÊÄÅÈ™åËØÅÁ†Å");
    } else {
        println!("{}", "‚ö†Ô∏è  Security Architecture:".yellow().bold());
        println!("  ‚Ä¢ Factor 1: Hardware Fingerprint (auto-collected, device-bound)");
        println!("  ‚Ä¢ Factor 2: Master Password (your strong password)");
        println!("  ‚Ä¢ Factor 3: Security Question Answer (prevents password leak)");
        println!("  ‚Ä¢ 2FA Key: Derived from hardware fingerprint + master password");
        println!("  ‚Ä¢ Unlock requires: Master password + Security answer + 2FA code");
    }
    println!();

    // Step 1: Collect hardware fingerprint
    if language == Language::Chinese {
        println!("{}", "Ê≠•È™§ 1/4: Êî∂ÈõÜÁ°¨‰ª∂ÊåáÁ∫π...".bright_blue());
    } else {
        println!("{}", "Step 1/4: Collecting hardware fingerprint...".bright_blue());
    }

    let hardware_fp = HardwareFingerprint::collect()
        .map_err(|e| format!("Failed to collect hardware fingerprint: {}", e))?;

    if language == Language::Chinese {
        println!("{} Á°¨‰ª∂ÊåáÁ∫πÂ∑≤Êî∂ÈõÜÔºàSHA256ÂìàÂ∏åÔºâ", "‚úÖ".green());
        println!("   ÊåáÁ∫πÈ¢ÑËßà: {}...", &hardware_fp.as_str()[..16]);
    } else {
        println!("{} Hardware fingerprint collected (SHA256 hash)", "‚úÖ".green());
        println!("   Preview: {}...", &hardware_fp.as_str()[..16]);
    }
    println!();

    // Step 2: Set master password
    if language == Language::Chinese {
        println!("{}", "Ê≠•È™§ 2/4: ËÆæÁΩÆ‰∏ªÂØÜÁ†Å".bright_blue());
    } else {
        println!("{}", "Step 2/4: Set master password".bright_blue());
    }

    let master_password = loop {
        let password = rpassword::prompt_password(
            if language == Language::Chinese { "ËØ∑ËæìÂÖ•‰∏ªÂØÜÁ†Å: " } else { "Enter master password: " }
        ).map_err(|e| format!("Failed to read password: {}", e))?;

        if password.is_empty() {
            println!("{} {}", "‚ùå".red(), if language == Language::Chinese { "‰∏ªÂØÜÁ†Å‰∏çËÉΩ‰∏∫Á©∫" } else { "Master password cannot be empty" });
            continue;
        }

        // Check password strength
        if password.len() < 10 {
            println!("{} {}", "‚ùå".red(), if language == Language::Chinese { "ÂØÜÁ†ÅÈïøÂ∫¶Ëá≥Â∞ë10‰∏™Â≠óÁ¨¶" } else { "Password must be at least 10 characters" });
            continue;
        }

        let password_confirm = rpassword::prompt_password(
            if language == Language::Chinese { "ËØ∑ÂÜçÊ¨°ËæìÂÖ•‰∏ªÂØÜÁ†ÅÁ°ÆËÆ§: " } else { "Confirm master password: " }
        ).map_err(|e| format!("Failed to read password: {}", e))?;

        if password != password_confirm {
            println!("{} {}", "‚ùå".red(), if language == Language::Chinese { "‰∏§Ê¨°ËæìÂÖ•ÁöÑÂØÜÁ†Å‰∏ç‰∏ÄËá¥" } else { "Passwords do not match" });
            continue;
        }

        break password;
    };

    if language == Language::Chinese {
        println!("{} ‰∏ªÂØÜÁ†ÅËÆæÁΩÆÊàêÂäü", "‚úÖ".green());
    } else {
        println!("{} Master password set successfully", "‚úÖ".green());
    }
    println!();

    // Step 3: Set security question
    if language == Language::Chinese {
        println!("{}", "Ê≠•È™§ 3/4: ËÆæÁΩÆÂÆâÂÖ®ÈóÆÈ¢ò".bright_blue());
    } else {
        println!("{}", "Step 3/4: Set security question".bright_blue());
    }

    let (question_index, _security_answer) = SecurityQuestion::setup_interactive()
        .map_err(|e| format!("Failed to setup security question: {}", e))?;
    println!();

    // Step 4: Setup 2FA
    if language == Language::Chinese {
        println!("{}", "Ê≠•È™§ 4/4: ËÆæÁΩÆ 2FA Âä®ÊÄÅÈ™åËØÅÁ†Å".bright_blue());
    } else {
        println!("{}", "Step 4/4: Setup 2FA TOTP".bright_blue());
    }

    let twofa_secret = derive_totp_secret_from_hardware_and_password(
        hardware_fp.as_str(),
        &master_password,
        account,
        issuer,
    ).map_err(|e| format!("Failed to derive 2FA secret: {}", e))?;

    let config = TOTPConfig {
        secret: twofa_secret.clone(),
        account: account.to_string(),
        issuer: issuer.to_string(),
        algorithm: "SHA1".to_string(),
        digits: 6,
        step: 30,
    };

    let totp_manager = TOTPManager::new(config);

    if language == Language::Chinese {
        println!("{}", "üì± ËØ∑‰ΩøÁî® Google Authenticator Êàñ Authy Êâ´Êèè‰ª•‰∏ã QR Á†ÅÔºö".yellow());
    } else {
        println!("{}", "üì± Scan this QR code with Google Authenticator or Authy:".yellow());
    }
    println!();

    match totp_manager.generate_qr_code() {
        Ok(qr_code) => {
            println!("{}", qr_code);
        }
        Err(e) => {
            if language == Language::Chinese {
                eprintln!("{} QR Á†ÅÁîüÊàêÂ§±Ë¥•: {}", "‚ö†Ô∏è".yellow(), e);
                println!("{}", "üìù ËØ∑ÊâãÂä®ËæìÂÖ•‰ª•‰∏ã‰ø°ÊÅØÔºö".yellow());
            } else {
                eprintln!("{} QR code generation failed: {}", "‚ö†Ô∏è".yellow(), e);
                println!("{}", "üìù Please enter this info manually:".yellow());
            }
            println!("{}", totp_manager.get_manual_setup_info());
        }
    }

    println!();
    if language == Language::Chinese {
        println!("{} ÊàñËÄÖÊâãÂä®ËæìÂÖ•ÂØÜÈí•: {}", "üîë".bright_cyan(), twofa_secret.bright_white());
    } else {
        println!("{} Or enter manually: {}", "üîë".bright_cyan(), twofa_secret.bright_white());
    }
    println!();

    // Verify 2FA setup
    loop {
        print!("{}", if language == Language::Chinese {
            "ËØ∑ËæìÂÖ•ËÆ§ËØÅÂô®ÊòæÁ§∫ÁöÑ 6 ‰ΩçÈ™åËØÅÁ†Å‰ª•Á°ÆËÆ§ËÆæÁΩÆ: "
        } else {
            "Enter the 6-digit code from your authenticator to verify: "
        });
        io::stdout().flush().map_err(|e| e.to_string())?;

        let mut input = String::new();
        io::stdin().read_line(&mut input).map_err(|e| e.to_string())?;
        let code = input.trim();

        match totp_manager.verify_code(code) {
            Ok(true) => {
                println!("{}", if language == Language::Chinese {
                    "‚úÖ 2FA È™åËØÅÊàêÂäüÔºÅ".green()
                } else {
                    "‚úÖ 2FA verification successful!".green()
                });
                break;
            }
            Ok(false) => {
                println!("{}", if language == Language::Chinese {
                    "‚ùå È™åËØÅÁ†Å‰∏çÊ≠£Á°ÆÔºåËØ∑ÈáçËØï".red()
                } else {
                    "‚ùå Code incorrect, please try again".red()
                });
                continue;
            }
            Err(e) => {
                eprintln!("{} {}: {}", "‚ùå".red(), if language == Language::Chinese { "È™åËØÅÂ§±Ë¥•" } else { "Verification failed" }, e);
                continue;
            }
        }
    }

    println!();
    if language == Language::Chinese {
        println!("{}", "üéâ ‰∏âÂõ†Â≠ê 2FA ËÆæÁΩÆÂÆåÊàêÔºÅ".green().bold());
        println!();
        println!("{}", "üìù ÈáçË¶Å‰ø°ÊÅØÔºàËØ∑Â¶•ÂñÑ‰øùÁÆ°Ôºâ:".yellow().bold());
        println!("  ‚Ä¢ Á°¨‰ª∂ÊåáÁ∫π: Â∑≤ÁªëÂÆöÂà∞ÂΩìÂâçËÆæÂ§á");
        println!("  ‚Ä¢ ÂÆâÂÖ®ÈóÆÈ¢ò: ÈóÆÈ¢ò {} - {}", question_index + 1, crate::security_question::SECURITY_QUESTIONS[question_index]);
        println!("  ‚Ä¢ 2FAÂØÜÈí•: Â∑≤Ê∑ªÂä†Âà∞ËÆ§ËØÅÂô®");
        println!();
        println!("{}", "üí° ‰∏ã‰∏ÄÊ≠•: ‰ΩøÁî®ÈÄâÈ°π5ÁîüÊàê‰∏âÂõ†Â≠êÈí±ÂåÖ".bright_blue());
    } else {
        println!("{}", "üéâ Triple-factor 2FA setup complete!".green().bold());
        println!();
        println!("{}", "üìù Important info (keep safe):".yellow().bold());
        println!("  ‚Ä¢ Hardware fingerprint: Bound to current device");
        println!("  ‚Ä¢ Security question: Question {} - {}", question_index + 1, crate::security_question::SECURITY_QUESTIONS[question_index]);
        println!("  ‚Ä¢ 2FA key: Added to authenticator");
        println!();
        println!("{}", "üí° Next step: Use option 5 to generate triple-factor wallet".bright_blue());
    }

    Ok(())
}

/// Generate triple-factor wallet interactively
#[cfg(feature = "2fa")]
fn generate_triple_factor_wallet_interactive(_language: Language) -> Result<(), String> {
    Err("This feature will be implemented soon. Please use CLI command: sol-safekey gen-2fa-wallet".to_string())
}

/// Unlock triple-factor wallet interactively
#[cfg(feature = "2fa")]
fn unlock_triple_factor_wallet_interactive(_language: Language) -> Result<(), String> {
    Err("This feature will be implemented soon. Please use CLI command: sol-safekey unlock-2fa-wallet -f <file>".to_string())
}

/// Read password with confirmation and validation
fn read_password_confirmed(texts: &Texts) -> Result<String, String> {
    println!("{}", texts.set_password);

    let password = prompt_password(texts.new_password, texts)?;

    if password.is_empty() {
        return Err(texts.password_empty.to_string());
    }

    if password.len() < 10 {
        return Err(texts.password_min_length.to_string());
    }

    let password_confirm = prompt_password(texts.confirm_password, texts)?;

    if password != password_confirm {
        return Err(texts.password_mismatch.to_string());
    }

    println!("{}", texts.password_set.green());
    Ok(password)
}
