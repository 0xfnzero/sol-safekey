//! Interactive Menu Module
//!
//! Provides a simple interactive interface - no need to memorize commands
//! Êèê‰æõÁÆÄÂçïÁöÑ‰∫§‰∫íÂºèÁïåÈù¢ - Êó†ÈúÄËÆ∞‰ΩèÂëΩ‰ª§

use std::io::{self, Write};
use colored::*;
use solana_sdk::signature::Keypair;
use solana_sdk::signer::Signer;

use crate::KeyManager;

/// Language selection
#[derive(Clone, Copy, PartialEq)]
enum Language {
    English,
    Chinese,
}

/// Text strings for bilingual UI
struct Texts {
    // Main menu
    title: &'static str,
    core_functions: &'static str,
    create_plain: &'static str,
    create_encrypted: &'static str,
    decrypt: &'static str,
    exit: &'static str,
    select_option: &'static str,
    goodbye: &'static str,
    invalid_option: &'static str,
    continue_use: &'static str,

    // Plain key creation
    create_plain_title: &'static str,
    keypair_generated: &'static str,
    public_key: &'static str,
    private_key: &'static str,
    output_method: &'static str,
    display_only: &'static str,
    save_to_file: &'static str,
    select: &'static str,
    file_path: &'static str,
    file_saved: &'static str,
    security_warning: &'static str,
    plaintext_warning: &'static str,
    save_securely: &'static str,
    dont_share: &'static str,
    recommend_encrypted: &'static str,

    // Encrypted key creation
    create_encrypted_title: &'static str,
    choose_method: &'static str,
    generate_new: &'static str,
    import_existing: &'static str,
    generating: &'static str,
    enter_private_key: &'static str,
    private_key_empty: &'static str,
    keypair_ready: &'static str,
    keystore_recommended: &'static str,
    show_encrypted_string: &'static str,
    keystore_created: &'static str,
    private_key_encrypted: &'static str,
    important_note: &'static str,
    keep_safe: &'static str,
    lost_password_warning: &'static str,
    backup_recommended: &'static str,
    encrypted_private_key: &'static str,
    keep_safe_both: &'static str,

    // Key decryption
    decrypt_title: &'static str,
    input_method: &'static str,
    from_keystore: &'static str,
    from_encrypted_string: &'static str,
    encrypted_key: &'static str,
    enter_password: &'static str,
    decrypt_success: &'static str,
    file_not_exist: &'static str,
    dont_share_warning: &'static str,
    delete_plaintext: &'static str,
    use_encryption: &'static str,

    // Password
    set_password: &'static str,
    new_password: &'static str,
    confirm_password: &'static str,
    password_empty: &'static str,
    password_min_length: &'static str,
    password_mismatch: &'static str,
    password_set: &'static str,

    // Errors
    invalid_choice: &'static str,
    write_failed: &'static str,
}

impl Texts {
    fn chinese() -> Self {
        Self {
            title: "  Sol-SafeKey - Solana ÂØÜÈí•ÁÆ°ÁêÜÂ∑•ÂÖ∑",
            core_functions: "Ê†∏ÂøÉÂäüËÉΩ (Âè™ÈúÄ3‰∏™Êìç‰Ωú):",
            create_plain: "  {}  ÂàõÂª∫ÊòéÊñáÁßÅÈí•",
            create_encrypted: "  {}  ÂàõÂª∫Âä†ÂØÜÁßÅÈí•",
            decrypt: "  {}  Ëß£ÂØÜÁßÅÈí•",
            exit: "  {}  ÈÄÄÂá∫",
            select_option: "ËØ∑ËæìÂÖ•ÈÄâÈ°π [0-3]: ",
            goodbye: "üëã ÂÜçËßÅÔºÅ",
            invalid_option: "‚ùå Êó†ÊïàÈÄâÈ°πÔºåËØ∑ÈáçÊñ∞ÈÄâÊã©",
            continue_use: "ÊòØÂê¶ÁªßÁª≠‰ΩøÁî®? [Y/n]: ",

            create_plain_title: "  ÂàõÂª∫ÊòéÊñáÁßÅÈí•",
            keypair_generated: "‚úÖ ÂØÜÈí•ÂØπÁîüÊàêÊàêÂäüÔºÅ",
            public_key: "ÂÖ¨Èí•Âú∞ÂùÄ:",
            private_key: "ÁßÅÈí•:",
            output_method: "ËæìÂá∫ÊñπÂºè:",
            display_only: "  1. ‰ªÖÊòæÁ§∫ (ÂΩìÂâçÂ∑≤ÊòæÁ§∫)",
            save_to_file: "  2. ‰øùÂ≠òÂà∞Êñá‰ª∂",
            select: "ËØ∑ÈÄâÊã© [1/2]: ",
            file_path: "Êñá‰ª∂Ë∑ØÂæÑ (ÈªòËÆ§: keypair.json): ",
            file_saved: "‚úÖ Â∑≤‰øùÂ≠òÂà∞Êñá‰ª∂",
            security_warning: "‚ö†Ô∏è  ÂÆâÂÖ®Ë≠¶Âëä:",
            plaintext_warning: "  ‚Ä¢ ÊòéÊñáÁßÅÈí•ÈùûÂ∏∏‰∏çÂÆâÂÖ®",
            save_securely: "  ‚Ä¢ ËØ∑Á´ãÂç≥‰øùÂ≠òÂà∞ÂÆâÂÖ®‰ΩçÁΩÆ",
            dont_share: "  ‚Ä¢ ‰∏çË¶ÅÂàÜ‰∫´Áªô‰ªª‰Ωï‰∫∫",
            recommend_encrypted: "  ‚Ä¢ Âª∫ËÆÆ‰ΩøÁî® 'ÂàõÂª∫Âä†ÂØÜÁßÅÈí•' ÂäüËÉΩ",

            create_encrypted_title: "  ÂàõÂª∫Âä†ÂØÜÁßÅÈí•",
            choose_method: "ÈÄâÊã©ÊñπÂºè:",
            generate_new: "  1. ÁîüÊàêÊñ∞ÁöÑÂØÜÈí•ÂØπÂπ∂Âä†ÂØÜ",
            import_existing: "  2. ÂØºÂÖ•Áé∞ÊúâÁßÅÈí•Âπ∂Âä†ÂØÜ",
            generating: "üé≤ ÁîüÊàêÊñ∞ÁöÑÂØÜÈí•ÂØπ...",
            enter_private_key: "ËØ∑ËæìÂÖ•ÁßÅÈí• (base58 Ê†ºÂºè): ",
            private_key_empty: "ÁßÅÈí•‰∏çËÉΩ‰∏∫Á©∫",
            keypair_ready: "‚úÖ ÂØÜÈí•ÂØπÂáÜÂ§áÂÆåÊàê",
            keystore_recommended: "  1. ‰øùÂ≠ò‰∏∫ Keystore Êñá‰ª∂ (Êé®Ëçê)",
            show_encrypted_string: "  2. ÊòæÁ§∫Âä†ÂØÜÂ≠óÁ¨¶‰∏≤",
            keystore_created: "  ‚úÖ Keystore ÂàõÂª∫ÊàêÂäüÔºÅ",
            private_key_encrypted: "üîí ÁßÅÈí•Â∑≤Âä†ÂØÜ‰øùÂ≠ò",
            important_note: "‚ö†Ô∏è  ÈáçË¶ÅÊèêÁ§∫:",
            keep_safe: "  ‚Ä¢ ËØ∑Â¶•ÂñÑ‰øùÁÆ° Keystore Êñá‰ª∂ÂíåÂØÜÁ†Å",
            lost_password_warning: "  ‚Ä¢ ‰∏¢Â§±ÂØÜÁ†ÅÂ∞ÜÊó†Ê≥ïÊÅ¢Â§çÈí±ÂåÖ",
            backup_recommended: "  ‚Ä¢ Âª∫ËÆÆÂ§á‰ªΩÂà∞ÂÆâÂÖ®‰ΩçÁΩÆ",
            encrypted_private_key: "Âä†ÂØÜÂêéÁöÑÁßÅÈí•:",
            keep_safe_both: "‚ö†Ô∏è  ÊèêÁ§∫: ËØ∑Â¶•ÂñÑ‰øùÁÆ°Âä†ÂØÜÁßÅÈí•ÂíåÂØÜÁ†Å",

            decrypt_title: "  Ëß£ÂØÜÁßÅÈí•",
            input_method: "ËæìÂÖ•ÊñπÂºè:",
            from_keystore: "  1. ‰ªé Keystore Êñá‰ª∂ËØªÂèñ",
            from_encrypted_string: "  2. ËæìÂÖ•Âä†ÂØÜÂ≠óÁ¨¶‰∏≤",
            encrypted_key: "Âä†ÂØÜÁöÑÁßÅÈí•: ",
            enter_password: "ËØ∑ËæìÂÖ•ÂØÜÁ†Å: ",
            decrypt_success: "  ‚úÖ Ëß£ÂØÜÊàêÂäüÔºÅ",
            file_not_exist: "Êñá‰ª∂‰∏çÂ≠òÂú®: {}",
            dont_share_warning: "  ‚Ä¢ ËØ∑ÂãøÂàÜ‰∫´ÁßÅÈí•Áªô‰ªª‰Ωï‰∫∫",
            delete_plaintext: "  ‚Ä¢ ‰ΩøÁî®ÂÆåÊØïÂêéËØ∑Á´ãÂç≥Âà†Èô§ÊòéÊñáÁßÅÈí•Êñá‰ª∂",
            use_encryption: "  ‚Ä¢ Âª∫ËÆÆ‰ΩøÁî®Âä†ÂØÜÊñπÂºè‰øùÂ≠ò",

            set_password: "ËÆæÁΩÆÂä†ÂØÜÂØÜÁ†Å (Ëá≥Â∞ë 10 ‰∏™Â≠óÁ¨¶):",
            new_password: "Êñ∞ÂØÜÁ†Å: ",
            confirm_password: "Á°ÆËÆ§ÂØÜÁ†Å: ",
            password_empty: "ÂØÜÁ†Å‰∏çËÉΩ‰∏∫Á©∫",
            password_min_length: "ÂØÜÁ†ÅÈïøÂ∫¶Ëá≥Â∞ë 10 ‰∏™Â≠óÁ¨¶",
            password_mismatch: "‰∏§Ê¨°ÂØÜÁ†Å‰∏ç‰∏ÄËá¥",
            password_set: "‚úÖ ÂØÜÁ†ÅËÆæÁΩÆÊàêÂäü",

            invalid_choice: "Êó†ÊïàÈÄâÈ°π",
            write_failed: "ÂÜôÂÖ•Êñá‰ª∂Â§±Ë¥•: {}",
        }
    }

    fn english() -> Self {
        Self {
            title: "  Sol-SafeKey - Solana Key Management Tool",
            core_functions: "Core Functions (3 operations):",
            create_plain: "  {}  Create Plain Private Key",
            create_encrypted: "  {}  Create Encrypted Private Key",
            decrypt: "  {}  Decrypt Private Key",
            exit: "  {}  Exit",
            select_option: "Select option [0-3]: ",
            goodbye: "üëã Goodbye!",
            invalid_option: "‚ùå Invalid option, please try again",
            continue_use: "Continue? [Y/n]: ",

            create_plain_title: "  Create Plain Private Key",
            keypair_generated: "‚úÖ Keypair generated successfully!",
            public_key: "Public Key:",
            private_key: "Private Key:",
            output_method: "Output Method:",
            display_only: "  1. Display Only (already shown)",
            save_to_file: "  2. Save to File",
            select: "Select [1/2]: ",
            file_path: "File path (default: keypair.json): ",
            file_saved: "‚úÖ Saved to file",
            security_warning: "‚ö†Ô∏è  Security Warning:",
            plaintext_warning: "  ‚Ä¢ Plaintext private key is very insecure",
            save_securely: "  ‚Ä¢ Save to a secure location immediately",
            dont_share: "  ‚Ä¢ Never share with anyone",
            recommend_encrypted: "  ‚Ä¢ Consider using 'Create Encrypted Private Key'",

            create_encrypted_title: "  Create Encrypted Private Key",
            choose_method: "Choose Method:",
            generate_new: "  1. Generate new keypair and encrypt",
            import_existing: "  2. Import existing private key and encrypt",
            generating: "üé≤ Generating new keypair...",
            enter_private_key: "Enter private key (base58 format): ",
            private_key_empty: "Private key cannot be empty",
            keypair_ready: "‚úÖ Keypair ready",
            keystore_recommended: "  1. Save as Keystore file (Recommended)",
            show_encrypted_string: "  2. Show encrypted string",
            keystore_created: "  ‚úÖ Keystore created successfully!",
            private_key_encrypted: "üîí Private key encrypted and saved",
            important_note: "‚ö†Ô∏è  Important:",
            keep_safe: "  ‚Ä¢ Keep Keystore file and password safe",
            lost_password_warning: "  ‚Ä¢ Lost password = lost wallet",
            backup_recommended: "  ‚Ä¢ Backup to a secure location",
            encrypted_private_key: "Encrypted Private Key:",
            keep_safe_both: "‚ö†Ô∏è  Note: Keep encrypted key and password safe",

            decrypt_title: "  Decrypt Private Key",
            input_method: "Input Method:",
            from_keystore: "  1. From Keystore file",
            from_encrypted_string: "  2. Enter encrypted string",
            encrypted_key: "Encrypted key: ",
            enter_password: "Enter password: ",
            decrypt_success: "  ‚úÖ Decryption successful!",
            file_not_exist: "File not found: {}",
            dont_share_warning: "  ‚Ä¢ Never share private key with anyone",
            delete_plaintext: "  ‚Ä¢ Delete plaintext key file after use",
            use_encryption: "  ‚Ä¢ Consider using encryption for storage",

            set_password: "Set encryption password (minimum 10 characters):",
            new_password: "New password: ",
            confirm_password: "Confirm password: ",
            password_empty: "Password cannot be empty",
            password_min_length: "Password must be at least 10 characters",
            password_mismatch: "Passwords do not match",
            password_set: "‚úÖ Password set successfully",

            invalid_choice: "Invalid choice",
            write_failed: "Write failed: {}",
        }
    }
}

/// ÈÄâÊã©ËØ≠Ë®Ä
fn select_language() -> Result<Language, String> {
    println!("\n{}", "=".repeat(50).cyan());
    println!("{}", "  Language / ËØ≠Ë®ÄÈÄâÊã©".cyan().bold());
    println!("{}", "=".repeat(50).cyan());
    println!();
    println!("  {}  English", "1.".green().bold());
    println!("  {}  ‰∏≠Êñá", "2.".green().bold());
    println!();
    print!("Select / ÈÄâÊã© [1/2]: ");
    io::stdout().flush().map_err(|e| e.to_string())?;

    let mut choice = String::new();
    io::stdin().read_line(&mut choice).map_err(|e| e.to_string())?;
    let choice = choice.trim();

    match choice {
        "1" => Ok(Language::English),
        "2" => Ok(Language::Chinese),
        _ => {
            println!("\n{}", "‚ùå Invalid option / Êó†ÊïàÈÄâÈ°π".red());
            select_language()
        }
    }
}

/// ÊòæÁ§∫‰∏ªËèúÂçïÂπ∂Â§ÑÁêÜÁî®Êà∑ÈÄâÊã©
pub fn show_main_menu() -> Result<(), String> {
    // È¶ñÂÖàÈÄâÊã©ËØ≠Ë®Ä
    let lang = select_language()?;
    let texts = match lang {
        Language::Chinese => Texts::chinese(),
        Language::English => Texts::english(),
    };

    loop {
        println!("\n{}", "=".repeat(50).cyan());
        println!("{}", texts.title.cyan().bold());
        println!("{}", "=".repeat(50).cyan());
        println!();
        println!("{}", texts.core_functions);
        println!();
        println!("  {}  {}", "1.".green().bold(), &texts.create_plain[6..]);
        println!("  {}  {}", "2.".green().bold(), &texts.create_encrypted[6..]);
        println!("  {}  {}", "3.".green().bold(), &texts.decrypt[6..]);
        println!("  {}  {}", "0.".red().bold(), &texts.exit[6..]);
        println!();
        print!("{}", texts.select_option);
        io::stdout().flush().map_err(|e| e.to_string())?;

        let mut choice = String::new();
        io::stdin().read_line(&mut choice).map_err(|e| e.to_string())?;
        let choice = choice.trim();

        match choice {
            "1" => create_plain_key_interactive(&texts)?,
            "2" => create_encrypted_key_interactive(&texts)?,
            "3" => decrypt_key_interactive(&texts)?,
            "0" => {
                println!("\n{}", texts.goodbye.cyan());
                break;
            }
            _ => {
                println!("\n{}", texts.invalid_option.red());
                continue;
            }
        }

        // ËØ¢ÈóÆÊòØÂê¶ÁªßÁª≠
        println!();
        print!("{}", texts.continue_use);
        io::stdout().flush().map_err(|e| e.to_string())?;

        let mut continue_choice = String::new();
        io::stdin().read_line(&mut continue_choice).map_err(|e| e.to_string())?;
        let continue_choice = continue_choice.trim().to_lowercase();

        if continue_choice == "n" || continue_choice == "no" {
            println!("\n{}", texts.goodbye.cyan());
            break;
        }
    }

    Ok(())
}

/// ÂäüËÉΩ1: ÂàõÂª∫ÊòéÊñáÁßÅÈí•
fn create_plain_key_interactive(texts: &Texts) -> Result<(), String> {
    println!("\n{}", "=".repeat(50).yellow());
    println!("{}", texts.create_plain_title.yellow().bold());
    println!("{}", "=".repeat(50).yellow());
    println!();

    // ÁîüÊàêÂØÜÈí•ÂØπ
    let keypair = KeyManager::generate_keypair();
    let pubkey = keypair.pubkey();
    let private_key = keypair.to_base58_string();

    println!("{}", texts.keypair_generated.green().bold());
    println!();
    println!("{} {}", texts.public_key.cyan(), pubkey.to_string().white().bold());
    println!("{} {}", texts.private_key.red().bold(), private_key);
    println!();

    // ËØ¢ÈóÆËæìÂá∫ÊñπÂºè
    println!("{}",texts.output_method);
    println!("{}", texts.display_only);
    println!("{}", texts.save_to_file);
    println!();
    print!("{}", texts.select);
    io::stdout().flush().map_err(|e| e.to_string())?;

    let mut output_choice = String::new();
    io::stdin().read_line(&mut output_choice).map_err(|e| e.to_string())?;
    let output_choice = output_choice.trim();

    if output_choice == "2" {
        print!("{}", texts.file_path);
        io::stdout().flush().map_err(|e| e.to_string())?;

        let mut file_path = String::new();
        io::stdin().read_line(&mut file_path).map_err(|e| e.to_string())?;
        let file_path = file_path.trim();
        let file_path = if file_path.is_empty() {
            "keypair.json"
        } else {
            file_path
        };

        // ‰øùÂ≠ò‰∏∫ Solana keypair JSON Ê†ºÂºè (Êï∞ÁªÑÊ†ºÂºè)
        let bytes = keypair.to_bytes();
        let json = serde_json::to_string(&bytes.to_vec())
            .map_err(|e| format!("{}", texts.write_failed.replace("{}", &e.to_string())))?;

        std::fs::write(file_path, json)
            .map_err(|e| format!("{}", texts.write_failed.replace("{}", &e.to_string())))?;

        println!();
        println!("{}", texts.file_saved.green());
        println!("{} {}", texts.file_path.trim_end_matches(':'), file_path);
    }

    println!();
    println!("{}", texts.security_warning.yellow().bold());
    println!("{}", texts.plaintext_warning);
    println!("{}", texts.save_securely);
    println!("{}", texts.dont_share);
    println!("{}", texts.recommend_encrypted);

    Ok(())
}

/// ÂäüËÉΩ2: ÂàõÂª∫Âä†ÂØÜÁßÅÈí•
fn create_encrypted_key_interactive(texts: &Texts) -> Result<(), String> {
    println!("\n{}", "=".repeat(50).yellow());
    println!("{}", texts.create_encrypted_title.yellow().bold());
    println!("{}", "=".repeat(50).yellow());
    println!();

    // ËØ¢ÈóÆÊòØÁîüÊàêÊñ∞ÁöÑËøòÊòØÂØºÂÖ•Áé∞ÊúâÁßÅÈí•
    println!("{}", texts.choose_method);
    println!("{}", texts.generate_new);
    println!("{}", texts.import_existing);
    println!();
    print!("{}", texts.select);
    io::stdout().flush().map_err(|e| e.to_string())?;

    let mut source_choice = String::new();
    io::stdin().read_line(&mut source_choice).map_err(|e| e.to_string())?;
    let source_choice = source_choice.trim();

    let keypair = match source_choice {
        "1" => {
            // ÁîüÊàêÊñ∞ÂØÜÈí•ÂØπ
            println!();
            println!("{}", texts.generating.cyan());
            KeyManager::generate_keypair()
        }
        "2" => {
            // ÂØºÂÖ•Áé∞ÊúâÁßÅÈí•
            println!();
            print!("{}", texts.enter_private_key);
            io::stdout().flush().map_err(|e| e.to_string())?;

            let mut private_key = String::new();
            io::stdin().read_line(&mut private_key).map_err(|e| e.to_string())?;
            let private_key = private_key.trim();

            if private_key.is_empty() {
                return Err(texts.private_key_empty.to_string());
            }

            Keypair::from_base58_string(private_key)
        }
        _ => {
            return Err(texts.invalid_choice.to_string());
        }
    };

    let pubkey = keypair.pubkey();

    println!();
    println!("{}", texts.keypair_ready.green());
    println!("{} {}", texts.public_key.cyan(), pubkey);
    println!();

    // Ëé∑ÂèñÂØÜÁ†Å
    let password = read_password_confirmed(texts)?;

    // ËØ¢ÈóÆËæìÂá∫ÊñπÂºè
    println!();
    println!("{}", texts.output_method);
    println!("{}", texts.keystore_recommended);
    println!("{}", texts.show_encrypted_string);
    println!();
    print!("{}", texts.select);
    io::stdout().flush().map_err(|e| e.to_string())?;

    let mut output_choice = String::new();
    io::stdin().read_line(&mut output_choice).map_err(|e| e.to_string())?;
    let output_choice = output_choice.trim();

    match output_choice {
        "1" => {
            // ‰øùÂ≠ò‰∏∫Êñá‰ª∂
            print!("{}", texts.file_path.replace("keypair", "wallet"));
            io::stdout().flush().map_err(|e| e.to_string())?;

            let mut file_path = String::new();
            io::stdin().read_line(&mut file_path).map_err(|e| e.to_string())?;
            let file_path = file_path.trim();
            let file_path = if file_path.is_empty() {
                "wallet.json"
            } else {
                file_path
            };

            let keystore_json = KeyManager::keypair_to_encrypted_json(&keypair, &password)?;
            std::fs::write(file_path, keystore_json)
                .map_err(|e| format!("{}", texts.write_failed.replace("{}", &e.to_string())))?;

            println!();
            println!("{}", "=".repeat(50).green());
            println!("{}", texts.keystore_created.green().bold());
            println!("{}", "=".repeat(50).green());
            println!();
            println!("{} {}", texts.file_path.trim_end_matches(':'), file_path);
            println!("{} {}", texts.public_key.cyan(), pubkey);
            println!("{}", texts.private_key_encrypted.green());
            println!();
            println!("{}", texts.important_note.yellow().bold());
            println!("{}", texts.keep_safe);
            println!("{}", texts.lost_password_warning);
            println!("{}", texts.backup_recommended);
        }
        "2" => {
            // ÊòæÁ§∫Âä†ÂØÜÂ≠óÁ¨¶‰∏≤
            let private_key = keypair.to_base58_string();
            let encrypted = KeyManager::encrypt_with_password(&private_key, &password)?;

            println!();
            println!("{}", texts.keypair_ready.green().bold());
            println!();
            println!("{} {}", texts.public_key.cyan(), pubkey);
            println!("{}", texts.encrypted_private_key.cyan());
            println!("{}", encrypted);
            println!();
            println!("{}", texts.keep_safe_both.yellow());
        }
        _ => {
            return Err(texts.invalid_choice.to_string());
        }
    }

    Ok(())
}

/// ÂäüËÉΩ3: Ëß£ÂØÜÁßÅÈí•
fn decrypt_key_interactive(texts: &Texts) -> Result<(), String> {
    println!("\n{}", "=".repeat(50).yellow());
    println!("{}", texts.decrypt_title.yellow().bold());
    println!("{}", "=".repeat(50).yellow());
    println!();

    // ÈÄâÊã©ËæìÂÖ•ÊñπÂºè
    println!("{}", texts.input_method);
    println!("{}", texts.from_keystore);
    println!("{}", texts.from_encrypted_string);
    println!();
    print!("{}", texts.select);
    io::stdout().flush().map_err(|e| e.to_string())?;

    let mut input_choice = String::new();
    io::stdin().read_line(&mut input_choice).map_err(|e| e.to_string())?;
    let input_choice = input_choice.trim();

    let (private_key, pubkey) = match input_choice {
        "1" => {
            // ‰ªéÊñá‰ª∂ËØªÂèñ
            print!("{}", texts.file_path.trim_end_matches("(ÈªòËÆ§: keypair.json): ").trim_end_matches("(default: keypair.json): "));
            io::stdout().flush().map_err(|e| e.to_string())?;

            let mut file_path = String::new();
            io::stdin().read_line(&mut file_path).map_err(|e| e.to_string())?;
            let file_path = file_path.trim();

            if !std::path::Path::new(file_path).exists() {
                return Err(format!("{}", texts.file_not_exist.replace("{}", file_path)));
            }

            println!();
            let password = prompt_password(texts.enter_password, texts)?;

            let keystore_json = std::fs::read_to_string(file_path)
                .map_err(|e| format!("{}", texts.write_failed.replace("{}", &e.to_string())))?;

            let keypair = KeyManager::keypair_from_encrypted_json(&keystore_json, &password)?;
            let pubkey = keypair.pubkey();
            let private_key = keypair.to_base58_string();

            (private_key, pubkey)
        }
        "2" => {
            // ËæìÂÖ•Âä†ÂØÜÂ≠óÁ¨¶‰∏≤
            print!("{}", texts.encrypted_key);
            io::stdout().flush().map_err(|e| e.to_string())?;

            let mut encrypted = String::new();
            io::stdin().read_line(&mut encrypted).map_err(|e| e.to_string())?;
            let encrypted = encrypted.trim();

            println!();
            let password = prompt_password(texts.enter_password, texts)?;

            let private_key = KeyManager::decrypt_with_password(encrypted, &password)?;
            let keypair = Keypair::from_base58_string(&private_key);
            let pubkey = keypair.pubkey();

            (private_key, pubkey)
        }
        _ => {
            return Err(texts.invalid_choice.to_string());
        }
    };

    println!();
    println!("{}", "=".repeat(50).green());
    println!("{}", texts.decrypt_success.green().bold());
    println!("{}", "=".repeat(50).green());
    println!();
    println!("{} {}", texts.public_key.cyan(), pubkey);
    println!("{} {}", texts.private_key.red().bold(), private_key);
    println!();

    // ËØ¢ÈóÆËæìÂá∫ÊñπÂºè
    println!("{}", texts.output_method);
    println!("{}", texts.display_only);
    println!("{}", texts.save_to_file);
    println!();
    print!("{}", texts.select);
    io::stdout().flush().map_err(|e| e.to_string())?;

    let mut output_choice = String::new();
    io::stdin().read_line(&mut output_choice).map_err(|e| e.to_string())?;
    let output_choice = output_choice.trim();

    if output_choice == "2" {
        let default_filename = if texts.file_path.contains("ÈªòËÆ§") {
            "decrypted_key.txt"
        } else {
            "decrypted_key.txt"
        };

        print!("{}", texts.file_path.replace("keypair.json", default_filename));
        io::stdout().flush().map_err(|e| e.to_string())?;

        let mut file_path = String::new();
        io::stdin().read_line(&mut file_path).map_err(|e| e.to_string())?;
        let file_path = file_path.trim();
        let file_path = if file_path.is_empty() {
            default_filename
        } else {
            file_path
        };

        let content = format!("{} {}\n{} {}\n", texts.public_key, pubkey, texts.private_key.trim_end_matches(':'), private_key);
        std::fs::write(file_path, content)
            .map_err(|e| format!("{}", texts.write_failed.replace("{}", &e.to_string())))?;

        println!();
        println!("{}", texts.file_saved.green());
        println!("{} {}", texts.file_path.trim_end_matches(':'), file_path);
    }

    println!();
    println!("{}", texts.security_warning.yellow().bold());
    println!("{}", texts.dont_share_warning);
    println!("{}", texts.delete_plaintext);
    println!("{}", texts.use_encryption);

    Ok(())
}

/// ËØªÂèñÂØÜÁ†ÅÔºàÈöêËóèËæìÂÖ•Ôºâ
/// Prompt and read password securely
fn prompt_password(prompt: &str, texts: &Texts) -> Result<String, String> {
    print!("{}", prompt);
    io::stdout().flush().map_err(|e| e.to_string())?;
    rpassword::read_password()
        .map_err(|e| format!("{}", texts.write_failed.replace("{}", &e.to_string())))
}

/// Read password with confirmation and validation
fn read_password_confirmed(texts: &Texts) -> Result<String, String> {
    println!("{}", texts.set_password);

    let password = prompt_password(texts.new_password, texts)?;

    if password.is_empty() {
        return Err(texts.password_empty.to_string());
    }

    if password.len() < 10 {
        return Err(texts.password_min_length.to_string());
    }

    let password_confirm = prompt_password(texts.confirm_password, texts)?;

    if password != password_confirm {
        return Err(texts.password_mismatch.to_string());
    }

    println!("{}", texts.password_set.green());
    Ok(password)
}
